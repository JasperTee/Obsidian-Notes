## 1. What is Usability?

### Definition

- Usability is **a measure** of how well a specific user, in a specific context, can use a product/design to achieve a defined goal **effectively, efficiently, and satisfactorily**.
    
- In other words:
    
    - It checks if people can actually use the product.
        
    - It considers both **task success** (did they finish the task?) and **experience quality** (was it easy and pleasant?).
        

---

### Position in UX Design

Usability is part of **User Experience (UX)** and sits **between utility and desirability**:

1. **Utility** – Is the product useful?
    
    - Can it do the job users need?
        
    - Example: A calculator app can calculate equations.
        
2. **Usability** – Is the product easy and enjoyable to use?
    
    - Does it make the process smooth?
        
    - Example: A calculator with a clean layout and large buttons.
        
3. **Desirability** – Is the product attractive and appealing?
    
    - Does the design and style make people _want_ to use it?
        
    - Example: A calculator with a modern design and animations.
        

---

### Useful vs. Usable

- **Useful** = Practical, helps to achieve the goal effectively.
    
- **Usable** = Pleasurable, the process of achieving the goal is enjoyable.
    

Example:

- A text editor that has all features but is hard to navigate → useful but **not usable**.
    
- A simple note-taking app that is easy and pleasant to use → less powerful but **highly usable**.
    

---

### Measuring Usability

- Usability is not tested only at the end but **throughout the development process**:
    
    - **Wireframes** (early sketches of the interface)
        
    - **Prototypes** (interactive mock-ups)
        
    - **Final product**
        
- This ensures usability problems are found early, before the product is released.
## 2. The 5 Es of Usability
![[The 5 Es of Usability.png]]
These are five main factors used to measure **usability** of a product or system.

---

### 1. **Effective**

- **Definition:** How completely and accurately users can achieve their goals.
    
- Meaning: Does the system allow users to accomplish what they want correctly?
    
- **Example:**
    
    - Google Maps gives correct directions to the destination → effective.
        
    - If the app shows the wrong location → not effective.
        

---

### 2. **Efficient**

- **Definition:** How quickly and with minimal resources a task can be completed.
    
- Meaning: Not just finishing the task, but finishing it in the best way.
    
- **Example:**
    
    - Using keyboard shortcuts like **Ctrl+C / Ctrl+V** is faster than using the mouse.
        
    - Amazon’s “1-click checkout” speeds up online purchases → efficient.
        

---

### 3. **Engaging**

- **Definition:** How well the interface draws users in, making the experience pleasant and satisfying.
    
- Meaning: Is it enjoyable and motivating to use?
    
- **Example:**
    
    - Duolingo makes learning fun with animations and rewards → engaging.
        
    - A plain e-learning site with only long text → less engaging.
        

---

### 4. **Error Tolerant**

- **Definition:** How well the system prevents errors, or helps users recover when errors occur.
    
- Meaning: Users should not easily make mistakes, and if they do, they can fix them quickly.
    
- **Example:**
    
    - Gmail shows a warning: “You forgot the subject line, send anyway?” → prevents error.
        
    - Microsoft Word allows **Undo/Redo** to fix mistakes.
        

---

### 5. **Easy to Learn**

- **Definition:** How quickly new users can learn to use the system, and how well they can continue to use it over time.
    
- Meaning: Users should not need heavy training or manuals.
    
- **Example:**
    
    - Instagram: open the app, and it’s immediately clear how to post a photo → easy to learn.
        
    - Complex software like AutoCAD requires long training before being usable → not easy to learn.
## 3. Usability Principles 

Scholars in **software engineering** and **human–computer interaction (HCI)** proposed different sets of principles to guide usability design. Here are three influential ones:

---

### **A. Preece et al. (1994)**

(From software engineering)

1. **Know the user population**
    
    - Designers must understand the needs, abilities, and contexts of their target users.
        
    - Example: An app for children uses large icons and bright colors; an app for engineers uses precise technical data.
        
2. **Reduce the cognitive load**
    
    - Don’t force users to memorize too much information.
        
    - Techniques: chunking, progressive disclosure, eliminating unnecessary details, avoiding visual clutter.
        
    - Example: A website groups menu items into categories instead of listing hundreds of links.
        
3. **Engineer for errors**
    
    - Users make mistakes. The system should prevent errors or allow recovery.
        
    - Example: Confirmation popup before deleting a file; “Undo” button in Word.
        
4. **Maintain consistency and clarity**
    
    - Operations, terminology, and metaphors should remain consistent.
        
    - Example: The “shopping cart” icon always means “add to cart” in e-commerce websites.
        

---

### **B. Sommerville (1995)**

(From _Software Engineering_)

1. **User familiarity**
    
    - Interfaces should use terms and concepts familiar to the target user group.
        
    - Example: A trash bin icon to represent deletion.
        
2. **Consistency**
    
    - Comparable operations should always be performed the same way.
        
    - Example: In Microsoft apps, **Ctrl+S** always means Save.
        
3. **Minimal surprise**
    
    - Systems should behave as users expect.
        
    - Example: Clicking the “X” button closes a window, not restarts the computer.
        
4. **Recoverability**
    
    - Users must be able to recover from errors.
        
    - Example: Undo/Redo functions; “Restore from Trash.”
        
5. **User guidance**
    
    - Provide context-sensitive help or hints.
        
    - Example: Tooltips when hovering over an icon.
        

---

### **C. Macaulay (1995)**

(From _Human–Computer Interaction for Software Designers_)

1. **Naturalness**
    
    - Users should not have to change their natural work style to interact with the system.
        
    - Example: Touch and gesture interactions on smartphones feel natural.
        
2. **Consistency**
    
    - Expectations from one part of the system should not be violated in another.
        
    - Example: If “+” means add item in one part of the app, it should mean the same everywhere.
        
3. **Non-redundancy**
    
    - Users should only input the minimum required information.
        
    - Example: A sign-up form asking only for email and password, instead of 10 personal details.
        
4. **Supportiveness**
    
    - The system should assist users through dialogue and guidance.
        
    - Example: Input suggestions while filling out forms.
        
5. **Flexibility**
    
    - Support both novice and expert users.
        
    - Example: Beginners use menus, while advanced users rely on shortcuts.
        

---
## 4. Nielsen’s 10 Usability Heuristics

### 1. **Visibility of System Status**

- The system should always inform users about what is happening, through timely feedback.
    
- **Example:** A progress bar during file upload shows how much is done.
    

---

### 2. **Match Between System and the Real World**

- Use concepts, language, and metaphors familiar to users.
    
- **Example:** A shopping cart icon in e-commerce sites mirrors a real shopping cart.
    

---

### 3. **User Control and Freedom**

- Users should be able to undo or redo actions, and escape unwanted states.
    
- **Example:** “Back” button in browsers; “Undo” in Photoshop.
    

---

### 4. **Consistency and Standards**

- Follow platform and industry conventions; don’t make users guess.
    
- **Example:** The “Play” icon (triangle) works the same across music apps.
    

---

### 5. **Error Prevention**

- Design systems to prevent errors before they occur, rather than just showing error messages.
    
- **Example:** Gmail warns you if you forgot to attach a file when you wrote “see attached.”
    

---

### 6. **Recognition Rather than Recall**

- Minimize memory load by making options visible.
    
- **Example:** Dropdown menus show all choices instead of forcing users to remember command names.
    

---

### 7. **Flexibility and Efficiency of Use**

- Allow users to tailor interactions; provide shortcuts for experts while keeping it simple for beginners.
    
- **Example:** Microsoft Word has menus for beginners, and keyboard shortcuts/macros for experts.
    

---

### 8. **Aesthetic and Minimalist Design**

- Interfaces should not contain irrelevant or unnecessary information.
    
- **Example:** Google’s homepage only shows the search bar and logo → minimal distractions.
    

---

### 9. **Help Users Recognize, Diagnose, and Recover from Errors**

- Error messages should be clear, written in plain language, and provide solutions.
    
- **Example:** Instead of “Error 404,” say: “Page not found. Check the URL or go back to the homepage.”
    

---

### 10. **Help and Documentation**

- Even if the system is usable without documentation, some help should be available.
    
- It should be easy to search, focused on user tasks, and concise.
    
- **Example:** In-app FAQs, guided tours, or tooltips.
    

---
## Connection Between Principles & Heuristics

### 1. **Nature**

- **Usability Principles**
    
    - Come from **academic research** (Preece, Sommerville, Macaulay).
        
    - Purpose: provide **theoretical guidance** for designing usable systems.
        
    - Example: _“Reduce cognitive load”_ → designers should not overwhelm users with too much information.
        
- **Usability Heuristics (Nielsen)**
    
    - Come from **practical design and evaluation**.
        
    - Purpose: provide **rules of thumb** to check user interfaces.
        
    - Example: _“Recognition rather than recall”_ → make options visible so users don’t need to remember.
        

---

### 2. **Similarities**

- Both aim to **improve user experience** by reducing difficulties, preventing errors, and making interaction more satisfying.
    
- They overlap in key areas:
    
    - **Consistency** → found in Preece, Sommerville, Macaulay, and Nielsen.
        
    - **Error handling** → principles (Engineer for errors, Recoverability) vs heuristics (Error prevention, Help users recover).
        
    - **User support** → principles (User guidance, Supportiveness) vs heuristics (Help & documentation).
        

---

### 3. **Differences**

- **Principles**
    
    - More **conceptual and theoretical**.
        
    - State _“how design should be”_.
        
    - Example: _“Know the user population”_ → designers must understand their users.
        
- **Heuristics**
    
    - More **practical and evaluative**.
        
    - State _“what to check when evaluating a UI”_.
        
    - Example: _“Visibility of system status”_ → check whether the interface informs users about what is happening.
        

---

### 4. **How They Work Together**

- **Principles** → used mainly during the **design phase** to shape the product.
    
- **Heuristics** → used mainly during the **evaluation phase** to test whether the design meets usability goals.
    

---

### 5. **Example**

- Principle: _“Reduce cognitive load”_ (Preece, 1994).
    
- Heuristic: _“Recognition rather than recall”_ (Nielsen, 2006).
    
- → Both address the same issue: reducing memory burden. The principle is **conceptual**, while the heuristic is **a concrete evaluation rule**.